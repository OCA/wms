!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).Vue2Storage = {}) }(this, function (e) { "use strict"; const t = {}; const r = new class { get length() { return Object.keys(this.storage).length } get storage() { return t } getItem(e) { return e in this.storage ? this.storage[e] : null } setItem(e, t) { this.storage[e] = t } removeItem(e) { e in this.storage && delete this.storage[e] } clear() { const e = Object.keys(this.storage); for (let t = 0; t <= e.length; t++)try { delete this.storage[e[t]] } catch (e) { } } }; class i extends Error { constructor(e, t) { super(e), this.name = "StorageError", t && (this.stack = t) } } const s = ["local", "session", "memory"]; var o; !function (e) { e.LOCAL = "local", e.SESSION = "session", e.MEMORY = "memory" }(o || (o = {})); class n { constructor(e = {}) { this.setOptions(e) } get length() { return this.keys().length } get prefix() { return this.options.prefix } get name() { return "vue2-storage" } get version() { return "6.1.3" } get driver() { switch (this.options.driver) { case o.LOCAL: default: return "undefined" != typeof window ? window.localStorage : r; case o.SESSION: return "undefined" != typeof window ? window.sessionStorage : r; case o.MEMORY: return r } } setOptions(e = {}) { this.checkConfig(e), this.options = Object.freeze({ prefix: e.prefix || "app_", driver: e.driver || o.LOCAL, ttl: e.ttl || 0, replacer: e.replacer || void 0 }) } get(e, t = null) { try { const r = this.fromJSON(this.addPrefix(e)); return null === r ? t : r } catch (e) { this.throwError(e) } } pull(e, t = null) { const r = this.get(e, t); return r !== t && this.remove(e), r } set(e, t, r = {}) { try { this.driver.setItem(this.addPrefix(e), this.toJSON(t, r)) } catch (e) { this.throwError(e) } } remember(e, t, r = {}) { return i = this, s = void 0, n = function* () { let i = this.get(e, null); if (null !== i) return i; try { return i = yield t(), this.set(e, i, r), i } catch (e) { this.throwError(e) } }, new ((o = void 0) || (o = Promise))(function (e, t) { function r(e) { try { a(n.next(e)) } catch (e) { t(e) } } function h(e) { try { a(n.throw(e)) } catch (e) { t(e) } } function a(t) { t.done ? e(t.value) : new o(function (e) { e(t.value) }).then(r, h) } a((n = n.apply(i, s || [])).next()) }); var i, s, o, n } remove(e) { try { this.driver.removeItem(this.addPrefix(e)) } catch (e) { this.throwError(e) } } clear(e = !1) { try { if (e) this.driver.clear(); else { this.keys().filter(e => e.startsWith(this.options.prefix || "")).forEach(e => this.remove(this.removePrefix(e))) } } catch (e) { this.throwError(e) } } has(e) { return this.removeExpiredValuesByKeys([this.addPrefix(e)]), this.options.driver !== o.MEMORY ? this.addPrefix(e) in this.driver : this.addPrefix(e) in this.driver.storage } key(e) { try { const t = this.keys()[e]; return this.get(this.removePrefix(t)) } catch (e) { this.throwError(e) } } keys() { let e = []; switch (this.options.driver) { case o.MEMORY: e = Object.keys(this.driver.storage); break; default: e = Object.keys(this.driver) }return e.filter(e => null !== this.fromJSON(e)) } checkConfig(e) { void 0 !== e.prefix && "string" != typeof e.prefix && this.throwError(new TypeError('Option "prefix" must be a string')), void 0 !== e.driver && (s.includes(e.driver) || this.throwError(new TypeError(`Option "driver" must be one of ${s.join(", ")}`))), void 0 !== e.ttl && "number" != typeof e.ttl && this.throwError(new TypeError('Option "ttl" must be a number')), void 0 !== e.replacer && "function" != typeof e.replacer && this.throwError(new TypeError('Option "replacer" must be a function')) } addPrefix(e) { return `${this.options.prefix || ""}${this.removePrefix(e)}` } removePrefix(e) { const t = new RegExp(`^${this.options.prefix || ""}`); return e.replace(t, "") } toJSON(e, t = {}) { const r = "ttl" in t ? t.ttl : this.options.ttl, { replacer: i } = this.options; return JSON.stringify({ value: e, ttl: r > 0 ? r + Date.now() : 0 }, (e, t) => i && "value" === e ? i(e, t) : t) } fromJSON(e) { try { this.removeExpiredValuesByKeys([e]); const t = JSON.parse(this.driver.getItem(e)); return null !== t ? "value" in t ? t.value : t : null } catch (e) { return null } } removeExpiredValuesByKeys(e) { try { e.forEach(e => { const t = JSON.parse(this.driver.getItem(e)); null !== t && "ttl" in t && Number(t.ttl) > 0 && Number(t.ttl) < Date.now() && this.remove(this.removePrefix(e)) }) } catch (e) { return null } } throwError(e) { throw new i(`${this.name}[${this.version}]: ${e.message}`, e.stack) } } class h { static install(e, t) { const r = new n(t || {}); e.$storage = r, e.prototype.$storage = r } } "undefined" != typeof window && (window.Vue2StoragePlugin = h, window.Vue2Storage = n), e.Plugin = h, e.default = n, Object.defineProperty(e, "__esModule", { value: !0 }) });